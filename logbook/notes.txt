PHASE 0 â€” Foundation 
Step 0.1 â€” Project setup

Folder structure

Build/run pipeline

âœ… Done

Step 0.2 â€” CLI argument parsing

Commands: new, view, check (You are here)

Proper usage errors

âœ… Done

Step 0.3 â€” Date validation (full)

DDMMYYYY

Leap years

Month/day correctness

ğŸŸ¡ In progress (almost done)

PHASE 1 â€” Filesystem & Persistence
Step 1.1 â€” Directory creation

logs/YYYY/MM/

std::filesystem

Step 1.2 â€” File path derivation

Map date â†’ path

Zero ambiguity

Step 1.3 â€” new command (write log)

Prompt user

Write structured file

Prevent overwrite

Step 1.4 â€” view command (read log)

Read file

Display nicely

Step 1.5 â€” check command (format validation)

Structural correctness

Parentheses balance

Summary brackets

PHASE 2 â€” Parsing & Data Modeling
Step 2.1 â€” Event parsing

Nested parentheses

Depth-based splitting

Step 2.2 â€” Internal structures

LogDay

Event

Step 2.3 â€” Semantic checks (optional)

Wake/sleep conventions

Warnings, not errors

PHASE 3 â€” Exports & Search
Step 3.1 â€” Master file generation

Derived artifact

Rebuildable

Step 3.2 â€” Search

Keyword

Date ranges

Event-based

PHASE 4 â€” Intelligence (later)
Step 4.1 â€” Memory resurfacing

â€œOn this dayâ€

Similar days

Step 4.2 â€” Stats

Sleep patterns

Activity streaks

PHASE 5 â€” UX & Polish
Step 5.1 â€” Interactive shell (optional)

REPL mode

Command history

Step 5.2 â€” Config & customization

Tags

Aliases
























Phase 1 â€” Core Logging (Detailed Breakdown)

Goal:
Make ./logbook new <date> reliably create and write daily logs in the correct structure.

Phase 1 â€” Step Map (High-Level)
Phase 1
â”‚
â”œâ”€â”€ 1.1  Date â†’ Path Resolution
â”œâ”€â”€ 1.2  Directory Creation
â”œâ”€â”€ 1.3  Log File Path Construction
â”œâ”€â”€ 1.4  Log File Open Mode Handling
â”œâ”€â”€ 1.5  New File Header Writing
â”œâ”€â”€ 1.6  Interactive Event Input
â”œâ”€â”€ 1.7  Event Persistence Rules
â””â”€â”€ 1.8  Safe Exit & Error Handling


Each step is small, testable, and isolated.

Step 1.1 â€” Date â†’ Path Resolution
Responsibility

Convert a validated date string (ddmmyyyy) into structured components.

Input
"25012025"

Output
year  = "2025"
month = "01"
day   = "25"

Why this step is isolated

Path logic must not depend on filesystem logic

Makes testing easier

Future reuse (view/check commands)

Completion Criteria

Correct extraction for any valid date

No filesystem operations here

Step 1.2 â€” Directory Creation
Responsibility

Ensure required directory hierarchy exists:

logs/YYYY/MM/

Rules

Use std::filesystem

Must be idempotent

Should not throw or crash if already exists

Why this matters

Prevents file-open failures

Makes structure predictable for future features

Completion Criteria

Running the command twice does not error

Directories exist after execution

Step 1.3 â€” Log File Path Construction
Responsibility

Construct the exact log file path.

Example
logs/2025/01/25012025.log

Rules

No file I/O yet

Pure string/path construction

Why separate?

Path correctness is critical

Reused by view and check

Completion Criteria

Path matches agreed format

Works for all dates

Step 1.4 â€” Log File Open Mode Handling
Responsibility

Open the log file correctly depending on existence.

Behavior
File Exists	Action
Yes	Open in append mode
No	Create new file
Why this step exists

Prevent accidental overwrites

Preserve past logs

Completion Criteria

Existing logs remain intact

New logs are created cleanly

Step 1.5 â€” New File Header Writing
Responsibility

Write a header only if file is new.

Format
Date: 25-01-2025
------------------

Rules

Header must never duplicate

Human-readable

Parsing-friendly

Completion Criteria

Header appears exactly once

Existing files are untouched

Step 1.6 â€” Interactive Event Input
Responsibility

Accept multiple user events interactively.

Rules

One event per line

Nested parentheses allowed

No interpretation or parsing

End Condition

Empty line terminates input

Completion Criteria

Accepts unlimited lines

Stops correctly on empty input

Step 1.7 â€” Event Persistence Rules
Responsibility

Persist events exactly as entered.

Rules

Preserve order

Preserve spacing

No formatting changes

Example

Input:

park(running(2 km))


Stored exactly as:

park(running(2 km))

Completion Criteria

Output matches input byte-for-byte

Events appended correctly

Step 1.8 â€” Safe Exit & Error Handling
Responsibility

Exit cleanly with clear messages.

Situations to handle

File open failure

Permission issues

Unexpected EOF

Rules

No silent failures

No crashes

Completion Criteria

Graceful termination

Useful console feedback